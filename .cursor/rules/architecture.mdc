---
description: 
globs: 
alwaysApply: true
---
# Project Structure and Guidelines

## Architecture Overview
- Follow the MVVM (Model-View-ViewModel)
- Use ValueNotifier for state management, these are always created within a viewmodel
- **App Services** (core/services/) handle app-wide state, only needed if you need to share state between viewmodels, they should be instantiated in the locator
- **Data Services** (data/services/) handle API communication, accessed ONLY via Repositories
- ViewModels handle page-specific state and logic
- Views only contain UI code other functionality related to context

## Dependency Flow
```
View → ViewModel → Repository → ApiService
  ↓         ↓
  └─────────→ App Services (AuthService, NotifyService)
```

**Rules:**
- Views can only access ViewModels
- ViewModels can access Repositories and App Services
- ViewModels NEVER access ApiService directly
- Repositories are the ONLY layer that accesses ApiService

Example of a view using a viewmodel:

```dart
class HomeView extends StatefulWidget {
  const HomeView({super.key});

  @override
  State<HomeView> createState() => _HomeViewState();
}

class _HomeViewState extends State<HomeView> {
  late final HomeViewModel _viewModel = HomeViewModel(
    notifyService: locator<NotifyService>(),
  );

  @override
  void dispose() {
    _viewModel.dispose();
    super.dispose();
  }

  // build method
}
```

## Directory Structure
- `lib/`
  - `config/`: configure routes and services
  - `core/`
    - `ui/`: plain widgets, should never take in viewmodels and other project specific inputs 
    - `services/`: Shared services and business logic
    - `utils/`: Helper functions, constants, and shared features such as navigation, http, translations
  - `data/`: (Layer-First Data Layer)
    - `models/`: DTOs with fromJson/toJson methods
    - `repositories/`: Abstract interfaces for data access
    - `services/`:
      - `api_service.dart`: Abstract base interface
      - `mock_api_service.dart`: Implementation with mock data

  - `feature_name/`
    - For simple features (≤5 files):
      Place files directly in feature folder
    - For complex features:
      - `models/`: Feature-specific models
      - `services/`: Feature-specific services
      - `viewmodels/`: Feature-specific viewmodels
      - `views/`: Feature UI components
      - `repositories/`: (Optional) Feature-specific data layer

## Architecture Rules - IMPORTANT
1. Views should never use services directly, just view models.
2. In theory, the view should contain no logic (this is not always possible) but defer logic to the view model as much as possible (that is its role)
3. View models should never use other view models. Move that shared functionality into a service and consume it from there.
4. View models should not have access to BuildContext. Defer to the view.
5. Dependencies should always be injected through the constructor.
6. ViewModels are responsible for cleaning up their own resources. Views should call the ViewModel's dispose method.
7. ValueNotifiers and other resources should be disposed in the ViewModel's dispose method, not directly in the View.
8. **Repository Pattern**: ViewModels communicate with the Data Layer via Repositories (Interfaces), never call Services directly.
9. **Mock Data**: All hardcoded lists/JSONs must reside in `lib/data/services/mock_api_service.dart`.

## State Management Strategy
Choose the appropriate state management approach based on screen complexity:

### Simple Screens (1-2 independent states)
- **Use**: `ValueNotifier<T>` or `ValueNotifier<AsyncValue<T>>`
- **Examples**: Login, Employee Detail, Dashboard widgets
- **When**: Single async operation, minimal interdependent state
```dart
class LoginViewModel {
  final AuthRepository _authRepository; // ✅ Repository, not Service
  final loginState = ValueNotifier<AsyncValue<void>>(const AsyncData(null));
  
  LoginViewModel({required AuthRepository authRepository})
      : _authRepository = authRepository;
  
  Future<void> login(String email, String password) async {
    loginState.value = const AsyncLoading();
    try {
      await _authRepository.login(email, password); // ✅ Via Repository
      loginState.value = const AsyncData(null);
    } catch (e) {
      loginState.value = AsyncError(e.toString());
    }
  }
}
```

### Medium Complexity (Multiple dependent fields)
- **Use**: `ChangeNotifier`
- **Examples**: Employee List with filters, Create Shift Dialog
- **When**: Multiple fields that depend on each other, computed properties
```dart
class EmployeeListViewModel extends ChangeNotifier {
  List<Employee> _employees = [];
  String? _searchQuery;
  
  List<Employee> get filteredEmployees {
    // Computed property automatically updates when notifyListeners() is called
    return _employees.where((e) =>
      e.firstName.contains(_searchQuery ?? '')
    ).toList();
  }
  
  void setSearchQuery(String query) {
    _searchQuery = query;
    notifyListeners(); // All listeners rebuild
  }
}
```

### High Complexity (Complex logic, many fields)
- **Use**: State Object Pattern with `ValueNotifier<State>`
- **Examples**: Schedule Calendar, Complex forms
- **When**: Many interdependent fields, complex state transitions, need immutability
```dart
class ScheduleState {
  final AsyncValue<List<Shift>> shifts;
  final DateTime selectedDate;
  final CalendarView view;
  
  const ScheduleState({
    this.shifts = const AsyncLoading(),
    required this.selectedDate,
    this.view = CalendarView.week,
  });
  
  ScheduleState copyWith({...}) => ScheduleState(...);
}

class ScheduleViewModel {
  final state = ValueNotifier<ScheduleState>(
    ScheduleState(selectedDate: DateTime.now())
  );
  
  void changeView(CalendarView newView) {
    state.value = state.value.copyWith(view: newView);
  }
}
```

### Async Operations
- **Always** wrap async operations in `AsyncValue<T>` (see `lib/core/utils/async_value.dart`)
- **Never** use raw `bool isLoading` + `String? error` pattern
- **Use** `AsyncValue.when()` for clean state handling in UI

**See**: `docs/state_management_guide.md` for detailed examples and best practices.

## Memory Management Rules
- All ViewModels MUST have a dispose() method
- All ValueNotifiers MUST be disposed in ViewModel.dispose()
- All StreamSubscriptions MUST be cancelled in ViewModel.dispose()
- Views MUST call ViewModel.dispose() in their dispose()
- Use ValueListenableBuilder instead of manual listeners
- **See**: `docs/memory_leaks_prevention.md` for detailed patterns

## Error Handling Rules
- All async operations MUST be wrapped in try-catch
- Use centralized ErrorHandler for consistent error processing
- Show user-friendly messages through NotifyService
- Use AsyncValue<T> for state management
- **See**: `docs/error_handling_strategy.md` for implementation guide

## Data Management Rules
- Use UUID package for generating unique IDs
- Validate ID uniqueness in MockApiService
- Use Request DTOs without ID fields
- Generate IDs in Repository layer
- **See**: `docs/uuid_generation_guide.md` for UUID patterns

## Mock Data Rules
- MockApiService should store data in memory for MVP
- Consider persistence only for Post-MVP phase
- Focus on speed and simplicity over data persistence
- **See**: `docs/mock_data_persistence.md` for persistence strategy


